import Discord from "discord.js";

import config from "./config.js";
import { ParseOrder } from "./DiscordParser.js";
import { Log, SendWithId } from "./DiscordHelper.js";
import { StringsAreEqual } from "./StringAssistant.js";

const commandLineArgs = process.argv[0] == "node" ? process.argv.slice(2) : process.argv; // ignore the first 2 as they are automatically generated by node.
let is_debug = null;
for (const arg of commandLineArgs) {
	if (StringsAreEqual(arg, "debug")) {
		is_debug = true;
		break;
	}
}
if (is_debug == null) {
	is_debug = config.is_debug;
}

const bot_secret = config.bot.bot_secret;

const {
	pastorders_channel_id: orders_channel_id,
	bot_commands_channel_id: bot_commands_channel_id,
	france_id,
	italy_id,
	ah_id,
	turk_id,
	rus_id,
	germ_id,
	eng_id,
	done_string,
	undone_string,
} = config.bot;

// Initialize Discord Bot
const client = new Discord.Client();

let timeout_id_do_the_thing = null;

const orders = {
	france: new Array(),
	italy: new Array(),
	ah: new Array(),
	turk: new Array(),
	rus: new Array(),
	germ: new Array(),
	eng: new Array(),
};

const done_statuses = {
	france: false,
	italy: false,
	ah: false,
	turk: false,
	rus: false,
	germ: false,
	eng: false,
};

const nations = [
	{
		name: "France",
		short_name: "france",
		channel_id: france_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
	{
		name: "Italy",
		short_name: "italy",
		channel_id: italy_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
	{
		name: "Austria-Hungary",
		short_name: "ah",
		channel_id: ah_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
	{
		name: "Turkey",
		short_name: "turk",
		channel_id: turk_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
	{
		name: "Russia",
		short_name: "rus",
		channel_id: rus_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
	{
		name: "Germany",
		short_name: "germ",
		channel_id: germ_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
	{
		name: "England",
		short_name: "eng",
		channel_id: eng_id,
		orders: new Array(),
		done_status: false,
		alive: false,
	},
];

const AliveNations = () => nations.filter((nation) => nation.alive);

const ClearOrders = function () {
	for (const nation of AliveNations()) {
		nation.orders = [];
		nation.done_status = false;
	}

	Log("orders cleared");
};

const DoTheThing = function () {
	let messageText = "";
	for (const nation of AliveNations()) {
		PrintNation(nation);
		for (const order of nation.orders) {
			if (order !== undefined && order.content.length > 0) {
				if (messageText.length > 0) {
					messageText += "\r\n";
				}
				messageText += nation.name + ': "' + order.content + '"';
			}
		}
		if (messageText.length > 0) {
			messageText += "\r\n";
		}
		messageText += "------";
	}

	Log("Did the thing:\r\n" + messageText);

	SendWithId(client, orders_channel_id, messageText);

	ClearOrders();
};

const AreAllDone = function () {
	return nations.every((nation) => nation.done_status);
};

const MarkDone = function (nation) {
	const prev_value = nation.done_status;
	nation.done_status = true;

	if (prev_value) {
		Log(nation.name + " is still done.");
	} else {
		Log(nation.name + " is done.");
	}

	if (AreAllDone()) {
		const delay = 3000 + Math.random() * 7000;
		timeout_id_do_the_thing = setInterval(function () {
			if (AreAllDone()) {
				DoTheThing();
				timeout_id_do_the_thing = null;
			} else {
				Log("Not doing the thing since not all are done.");
			}
		}, delay);
	}
};

const MarkUndone = function (nation) {
	const prev_value = nation.done_status;
	nation.done_status = false;

	if (prev_value) {
		Log(nation.name + " is undone.");
	} else {
		Log(nation.name + " is still not done.");
	}

	if (!AreAllDone()) {
		clearInterval(timeout_id_do_the_thing);
	} else {
		Log(nation.name + " undone themselves but somehow everyone was still done :shrug:");
	}
};

const AddToList = function (nation, message) {
	if (message.content.toLowerCase().startsWith(done_string)) {
		MarkDone(nation);
	} else if (message.content.toLowerCase().startsWith(undone_string)) {
		MarkUndone(nation);
	} else {
		// TODO allow for attachments?
		const my_order_object = {
			name: nation.name,
			id: message.id,
			content: message.content,
		};
		nation.orders.push(my_order_object);
		
		// TODO Should only do the parsing once user types done.
		//ParseOrder(message);

		let msg = "added message for " + nation.name;
		if (is_debug) msg += ` saying "${message.content}"`;
		Log(msg);
		PrintNation(nation);
	}
};

const ProcessMessage = (receivedMessage) => {
	if (receivedMessage.channel.id === orders_channel_id) {
		if (receivedMessage.content.toLowerCase().startsWith("go")) {
			DoTheThing();
		} else if (receivedMessage.content.toLowerCase().startsWith("clear")) {
			ClearOrders();
		}
		return;
	}

	if (receivedMessage.channel.id === bot_commands_channel_id) {
		ProcessCommand(receivedMessage);
	}

	for (const nation of nations) {
		if (receivedMessage.channel.id === nation.channel_id) {
			AddToList(nation, receivedMessage);
		}
	}
};

const ProcessMessageEdit = (oldMessage, newMessage) => {
	const all_orders = nations.reduce((accumulator, nation) => {
		accumulator.push(...nation.orders); // ... is the spread operator
	}, new Array());

	// Take first element that matches, if falsey then use null.
	const message_to_edit = all_orders.filter((order) => order.id === newMessage.id)[0] || null;
	if (message_to_edit != null) {
		message_to_edit.content = newMessage.content;

		let msg = "A message from " + message_to_edit.nation.name + " was edited";
		if (is_debug) msg += ' from "' + oldMessage.content + '" to "' + newMessage.content + '"';
		Log(msg);
	} else {
		for (const nation of nations) {
			if (receivedMessage.channel.id === nation.channel_id) {
				let msg =
					"A message for " +
					nation.name +
					" was edited but it wasn't stored in our list of orders so nothing happened.";
				if (is_debug) {
					msg +=
						'\r\nThe message was edited from "' +
						oldMessage.content +
						'" to "' +
						newMessage.content +
						'"';
				}
				Log(msg);
				return;
			}
		}
	}
}

const ProcessCommand = (message) => {
	
}

const PrintNation = (nation) => {
	const msg = `Name: ${nation.name} (${nation.short_name})
	Orders: ${nation.orders.length}, Alive: ${nation.alive ? "true" : "false"}, Done: ${nation.done_status ? "true" : "false"}`;
	Log(msg);
}

client.on("ready", (evt) => {
	Log("Connected");
	Log("Logged in as: " + client.user.tag);
});

client.on("message", (receivedMessage) => {
	// Prevent bot from responding to its own messages
	if (receivedMessage.author === client.user) {
		return;
	}

	ProcessMessage(receivedMessage);
});

client.on("messageUpdate", ProcessMessageEdit);

Log("Started running" + (is_debug ? " in debug mode" : ""));
client.login(bot_secret);
